{% extends 'main.html' %}
{% load static %}
{% block content %}
<div id="chess-game" data-game_id="{{ game.id }}">
<div class="chess-game-container">
    {% if request.user == game.player1 or request.user == game.player2 %}
    <div class="game-header">
        <h1>Игра в комнате: {{ game.room.name }}</h1>
        <div class="player-info opponent-info moved">
            {% if request.user == game.player1 %}
                <div class="player-box player2">
                    <!-- <span class="player-name">{{ game.player2.username }}</span> -->
                    <span>{{player2_rating}}</span>
                </div>
            {% elif request.user == game.player2 %}
                <div class="player-box player1">
                    <!-- <span class="player-name">{{ game.player1.username }}</span> -->
                    <span>{{player1_rating}}</span>
    
                </div>
            {% endif %}
    </div>
    {% endif %}
    {% if request.user != game.player1 and request.user != game.player2 %}
    <div class="not-player-message">
        <h2>Вы не являетесь участником этой игры</h2>
        <p>Вы можете наблюдать за игрой, но не можете делать ходы.</p>
    </div>
    {% endif %}
    <!-- Блок "кто против кого" показывается только для зрителей -->
    {% if request.user != game.player1 and request.user != game.player2 %}
    <div class="player-info opponent-info">
        <div class="player-box player1">
            <!-- <span class="player-name">{{ game.player1.username }}</span> -->
            <span class="player-rating">({{player1_rating}})</span>
        </div>
        <div class="vs-text">против</div>
        <div class="player-box player2">
            <!-- <span class="player-name">{{ game.player2.username }}</span> -->
            <span class="player-rating">({{player2_rating}})</span>
        </div>
        <div class="game-status">
            Статус: <span class="status-badge">{% if game.is_active %}Активна{% else %}Завершена{% endif %}</span>
        </div>
    </div>
    {% endif %}

    <div class="chess-layout">
        <div class="chess-main">
            <!-- Top letters (a-h) -->
            <div class="board-letters" id="top-letters">
                {% for letter in 'abcdefgh' %}
                <span class="board-coord">{{ letter }}</span>
                {% endfor %}
            </div>

            <div class="board-center">
                <!-- Left numbers (1-8) -->
                <div class="board-numbers" id="left-numbers">
                    {% for number in '12345678' %}
                    <span class="board-coord">{{ number }}</span>
                    {% endfor %}
                </div>

                <!-- Chess board -->
                <div class="chess-board-wrapper">
                    <div class="chess-board" id="chess-board">
                        {% for row in '12345678' %}
                        {% for col in 'abcdefgh' %}
                        <div class="chess-square {% cycle 'white' 'black' as squarecolor %}" 
                             data-row="{{ forloop.parentloop.counter0 }}" 
                             data-col="{{ forloop.counter0 }}"
                             data-coord="{{ col }}{{ row }}">
                            <img class="piece" src="" alt="">
                        </div>
                        {% endfor %}
                        {% cycle squarecolor %}
                        {% endfor %}
                    </div>
                </div>

                <!-- Right numbers (1-8) -->
                <div class="board-numbers" id="right-numbers">
                    {% for number in '12345678' %}
                    <span class="board-coord">{{ number }}</span>
                    {% endfor %}
                </div>
            </div>

            <!-- Bottom letters (a-h) -->
            <div class="board-letters" id="bottom-letters">
                {% for letter in 'abcdefgh' %}
                <span class="board-coord">{{ letter }}</span>
                {% endfor %}
            </div>
        </div>

        <div class="right-sidebar">
            <div class="game-controls">
                <div class="current-turn" id="current-player"></div>
                <div class="game-state" id="game-status"></div>
        
                <div class="captured-pieces-container">
                    <div class="captured-title">Съеденные фигуры:</div>
                    <div class="captured-white">
                        <span class="captured-label">Белые:</span>
                        <div id="white-captured" class="captured-list"></div>
                    </div>
                    <div class="captured-black">
                        <span class="captured-label">Чёрные:</span>
                        <div id="black-captured" class="captured-list"></div>
                    </div>
                </div>
            </div>
        
            <div class="message-block-container">
                {% include 'baseapp/message_block.html' %}
            </div>
        </div>
    </div>
</div>
</div>


<style>
    .main-content {
        background-color: #2a2a2a;
    }
    .not-player-message {
        text-align: center;
        padding: 40px;
        background-color: #3a3a3a;
        border-radius: 10px;
        margin: 20px;
        color: #e0e0e0;
    }
    
    .not-player-message h2 {
        color: #f0f0f0;
        margin-bottom: 15px;
    }
    .chess-game-container {
        max-width: auto;
        padding: 20px;
        background-color: #2a2a2a;
        border-radius: 10px;
        color: #e0e0e0;
    }

    .game-header {
        text-align: center;
        margin-bottom: 25px;
    }

    .game-header h1 {
        color: #f0f0f0;
        margin-bottom: 15px;
    }

    .player-info {
        display: flex;
        gap: 15px;
        flex-wrap: wrap;
        margin: 20px 0;
        justify-content: center;
        align-items: center;
    }

    .opponent-info {
        margin-bottom: 10px;
    }

    .current-player-info {
        margin-top: 10px;
    }

    .player-box {
        padding: 10px 20px;
        border-radius: 8px;
        font-weight: bold;
        box-shadow: 0 2px 5px rgba(0, 0, 0, 0.3);
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .player1 {
        background-color: #3a3a3a;
        border: 2px solid #b58863;
        color: #f0d9b5;
    }

    .player2 {
        background-color: #1a1a1a;
        border: 2px solid #f0d9b5;
        color: #b58863;
    }

    .player-name {
        font-size: 1.1em;
        margin-bottom: 5px;
    }

    .player-rating {
        font-size: 1.4em;
        opacity: 0.8;
    }

    .vs-text {
        font-size: 1.2em;
        color: #e0e0e0;
        font-weight: bold;
    }

    .player-label {
        margin-right: 8px;
    }

    .game-status {
        align-self: center;
        color: #e0e0e0;
        margin-left: 20px;
    }

    .status-badge {
        background-color: #333;
        padding: 5px 10px;
        border-radius: 15px;
        font-weight: bold;
        color: #e0e0e0;
    }

    .chess-layout {
        display: flex;
        flex-direction: row;
        gap: 30px;
        align-items: flex-start;
    }

    @media (max-width: 1200px) {
        .chess-layout {
            flex-direction: column;
            align-items: center;
        }
        
        .right-sidebar {
            width: 100%;
            margin-top: 30px;
        }
    }

    .chess-main {
        display: flex;
        flex-direction: column;
        align-items: center;
    }

    .board-center {
        display: flex;
        align-items: center;
    }

    .chess-board-wrapper {
        position: relative;
    }

    /* Board coordinates styling */
    .board-letters {
        display: flex;
        justify-content: space-around;
        width: 480px;
        margin: 5px 0;
        font-weight: bold;
        user-select: none;
        color: #e0e0e0;
        font-size: 1.1em;
    }

    .board-numbers {
        display: flex;
        flex-direction: column;
        justify-content: space-around;
        height: 480px;
        margin: 0 5px;
        font-weight: bold;
        user-select: none;
        color: #e0e0e0;
        font-size: 1.1em;
    }

    .board-coord {
        display: inline-block;
        width: 60px;
        text-align: center;
    }

    /* Chess board styling */
    .chess-board {
        display: grid;
        grid-template-columns: repeat(8, 60px);
        grid-template-rows: repeat(8, 60px);
        border: 3px solid #444;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.4);
    }

    .chess-square {
        position: relative;
        width: 60px;
        height: 60px;
        display: flex;
        justify-content: center;
        align-items: center;
        cursor: pointer;
    }

    .white {
        background-color: #f0d9b5;
    }

    .black {
        background-color: #b58863;
    }

    .piece {
        width: 85%;
        height: 85%;
        object-fit: contain;
    }

    /* Board interaction states */
    .selected {
        background-color: rgba(50, 120, 60, 0.7) !important;
    }

    .possible-move::after {
        content: '';
        position: absolute;
        width: 25px;
        height: 25px;
        background-color: rgba(50, 120, 60, 0.5);
        border-radius: 50%;
    }

    .attackable-piece {
        background-color: rgba(200, 50, 50, 0.5) !important;
    }

    /* Right sidebar styling */
    .right-sidebar {
        display: flex;
        flex-direction: column;
        gap: 30px;
        min-width: 350px;
    }

    .game-controls {
        padding: 20px;
        background-color: #333;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
        color: #e0e0e0;
    }

    .current-turn {
        font-size: 1.3em;
        font-weight: bold;
        padding: 12px;
        margin-bottom: 15px;
        text-align: center;
        border-radius: 5px;
        background-color: #3a3a3a;
    }

    .player-white {
        color: #f0d9b5;
        border-left: 4px solid #f0d9b5;
    }

    .player-black {
        color: #b58863;
        border-left: 4px solid #b58863;
    }

    .game-state {
        font-size: 1.2em;
        padding: 12px;
        margin-bottom: 20px;
        text-align: center;
        border-radius: 5px;
    }

    .status-normal {
        background-color: #2a3a2a;
        color: #8bc34a;
    }

    .status-check {
        background-color: #3a2a2a;
        color: #ff6b6b;
        font-weight: bold;
    }

    .status-checkmate {
        background-color: #5a1a1a;
        color: #ff4444;
        font-weight: bold;
    }

    .status-stalemate {
        background-color: #3a3a2a;
        color: #ffcc00;
        font-weight: bold;
    }

    .captured-pieces-container {
        margin-top: 25px;
    }

    .captured-title {
        font-weight: bold;
        margin-bottom: 10px;
        padding-bottom: 5px;
        border-bottom: 1px solid #444;
        font-size: 1.1em;
    }

    .captured-white,
    .captured-black {
        display: flex;
        align-items: center;
        margin: 8px 0;
    }

    .captured-label {
        min-width: 70px;
        font-weight: bold;
    }

    .captured-list {
        display: flex;
        flex-wrap: wrap;
        gap: 5px;
    }

    .captured-piece {
        width: 25px;
        height: 25px;
        filter: brightness(0.9);
    }

    /* Promotion dialog */
    .promotion-dialog-overlay {
        position: fixed;
        top: 0;
        left: 0;
        right: 0;
        bottom: 0;
        background-color: rgba(0, 0, 0, 0.7);
        display: flex;
        justify-content: center;
        align-items: center;
        z-index: 100;
    }

    .promotion-dialog {
        background-color: #333;
        padding: 25px;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.4);
        color: #e0e0e0;
    }

    .promotion-title {
        margin-bottom: 20px;
        font-weight: bold;
        font-size: 1.3em;
        color: #f0f0f0;
    }

    .promotion-options {
        display: grid;
        grid-template-columns: repeat(2, 1fr);
        gap: 15px;
    }

    .promotion-option {
        padding: 15px;
        border: 1px solid #555;
        border-radius: 5px;
        cursor: pointer;
        transition: all 0.2s;
        background-color: #444;
    }

    .promotion-option:hover {
        background-color: #555;
        transform: translateY(-2px);
    }

    /* Message block styling */
    .message-block-container {
        width: 100%;
    }

    .chat-container {
        width: 100%;
        height: 400px;
        padding: 20px;
        border-radius: 10px;
        background-color: #333;
        box-shadow: 0 5px 15px rgba(0, 0, 0, 0.3);
        color: #e0e0e0;
        box-sizing: border-box;
        display: flex;
        flex-direction: column;
    }

    .messages {
        flex-grow: 1;
        overflow-y: auto;
        padding-right: 10px;
        margin-bottom: 15px;
    }
    .moved{
        margin: 20px 0;
        gap: 30px;
        margin-left: auto;
        justify-content: left;
        align-items: left;
        padding-left: 40px;
    }
    .message {
        margin-bottom: 15px;
        padding: 10px;
        border-radius: 5px;
        background-color: #3a3a3a;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
    }

    .message .text {
        font-size: 16px;
        color: #f0f0f0;
    }

    .message .author {
        font-size: 14px;
        color: #b58863;
        margin-top: 5px;
    }

    .message .author::before {
        content: "by ";
        color: #999;
    }

    .form-container {
        display: flex;
        align-items: center;
        gap: 10px;
        margin-top: auto;
    }

    .form-container input[type="text"] {
        flex-grow: 1;
        padding: 10px;
        border: 1px solid #555;
        border-radius: 5px;
        font-size: 16px;
        background-color: #444;
        color: #f0f0f0;
    }

    .form-container button {
        padding: 10px 15px;
        background-color: #b58863;
        border: none;
        color: white;
        cursor: pointer;
        border-radius: 5px;
        transition: background-color 0.2s;
    }

    .form-container button:hover {
        background-color: #9a6b4a;
    }
</style>
<script>
    class ChessGame {
    constructor(gameId) {
        // console.log(gameId)
        this.gameId = gameId;
        this.socket = null;
        this.playerColor = null;
        this.initializeSocket();
        this.castlingRights = {
            white: { kingside: true, queenside: true },
            black: { kingside: true, queenside: true }
        };
        this.capturedPieces = {
            white: [],
            black: []
        };
        this.boardLength = 8;
        this.pieces = Array(8).fill().map(() => Array(8).fill(''));
        this.currentPlayer = 'white';
        this.selectedPiece = null;
        this.possibleMoves = [];
        this.lastMove = null;
        this.gameOver = false;
        this.pendingPromotion = null;
        this.moveCount = 0;
        this.lastCaptureOrPawnMove = 0;
        this.gameStatus = 'active'; // 'active', 'checkmate', 'draw'
        this.winner = null;
        this.isWhite = null;
        this.winner_user = null;
        this.username = null;
        this.isPlayer = document.querySelector('.player1, .player2') !== null;

        this.pieceImages = {
            'p': '/static/images/black-pawn.png',
            'r': '/static/images/black-rook.png',
            'n': '/static/images/black-knight.png',
            'b': '/static/images/black-bishop.png',
            'q': '/static/images/black-queen.png',
            'k': '/static/images/black-king.png',
            'P': '/static/images/white-pawn.png',
            'R': '/static/images/white-rook.png',
            'N': '/static/images/white-knight.png',
            'B': '/static/images/white-bishop.png',
            'Q': '/static/images/white-queen.png',
            'K': '/static/images/white-king.png'
        };

        this.initBoard();
        this.renderBoard();
        this.addEventListeners();
        this.updateGameStatus('Подключаемся к игре...');
    }
    getDisplayedRow(row) {
            return this.playerColor === 'white' ? row : 7 - row;
        }

        updateBoardCoordinates() {
            const isWhitePerspective = this.playerColor === 'white';
            
            // Буквы (a-h)
            const letters = ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h'];
            const letterElements = document.querySelectorAll('.board-coord');
            
            // Цифры (1-8)
            const numbers = isWhitePerspective ? ['8', '7', '6', '5', '4', '3', '2', '1'] 
                                            : ['1', '2', '3', '4', '5', '6', '7', '8'];
            
            // Обновляем буквы
            for (let i = 0; i < 8; i++) {
                if (i < letterElements.length) {
                    letterElements[i].textContent = letters[i];
                }
            }
            
            // Обновляем цифры
            const numberElements = document.querySelectorAll('.board-numbers .board-coord');
            for (let i = 0; i < 8; i++) {
                if (i < numberElements.length) {
                    numberElements[i].textContent = numbers[i];
                }
            }
        }
        updateCapturedPiecesDisplay() {
        const whiteCaptured = document.getElementById('white-captured');
        const blackCaptured = document.getElementById('black-captured');
        
        // Очищаем текущее отображение
        whiteCaptured.innerHTML = '';
        blackCaptured.innerHTML = '';
        
        // Отображаем фигуры, съеденные черными (потерянные белыми)
        this.capturedPieces.white.forEach(piece => {
            const img = document.createElement('img');
            img.className = 'captured-piece';
            img.src = this.getPieceImage(piece, true); // true - белые фигуры
            whiteCaptured.appendChild(img);
        });
        
        // Отображаем фигуры, съеденные белыми (потерянные черными)
        this.capturedPieces.black.forEach(piece => {
            const img = document.createElement('img');
            img.className = 'captured-piece';
            img.src = this.getPieceImage(piece, false); // false - черные фигуры
            blackCaptured.appendChild(img);
        });
    }
    getPieceImage(piece, isWhite) {
        // Определяем цвет фигуры
        const colorPrefix = isWhite ? 'white' : 'black';
        
        // Маппинг символов фигур на названия файлов
        const pieceMap = {
            'p': 'pawn',
            'n': 'knight',
            'b': 'bishop',
            'r': 'rook',
            'q': 'queen',
            'k': 'king'
        };
        
        const pieceName = pieceMap[piece.toLowerCase()];
        return `/static/images/${colorPrefix}-${pieceName}.png`;
    }
    initializeSocket() {
        console.log(`Connecting to WebSocket for game ${this.gameId}...`);
        
        const protocol = window.location.protocol === 'https:' ? 'wss://' : 'ws://';
        this.socket = new WebSocket(`${protocol}${window.location.host}/ws/game/${this.gameId}/`);

        this.socket.onopen = () => {
            console.log('WebSocket connection established');
            this.updateGameStatus('Ожидаем начала игры...');
        };

        this.socket.onerror = (error) => {
            console.error('WebSocket error:', error);
            this.updateGameStatus('Ошибка подключения', 'error');
        };

        this.socket.onclose = (event) => {
            console.log('WebSocket disconnected:', event.reason);
            this.updateGameStatus('Соединение прервано', 'error');
        };

        this.socket.onmessage = (event) => {
            try {
                const data = JSON.parse(event.data);
            //    console.log('Received message:', data);
                
                switch(data.type) {
                    case 'game_init':
                        this.handleGameInit(data);
                        break;
                    case 'game_update':
                        this.handleGameUpdate(data);
                        break;
                    default:
                        // console.warn('Unknown message type:', data.type);
                }
            } catch (error) {
                console.error('Error parsing message:', error);
            }
        };
    }
  
    handleGameInit(data) {
        console.log(data)
        if (!data.board || !data.player_color) {
            // console.error('Invalid game initialization data');
            return;
        }

        this.playerColor = data.player_color;
        this.pieces = data.board;
        this.currentPlayer = data.current_player;
        this.capturedPieces = data.captured_pieces
        this.isWhite = this.playerColor === 'white' ? true: false 
        // console.log(`Player color: ${this.playerColor}, Current player: ${this.currentPlayer}`); // Добавьте лог
        this.updateGameStatus(
            this.isMyTurn() ? 'Ваш ход!' : 'Ожидаем хода соперника'
        );
        this.renderBoard();
    }

    // handleGameUpdate(data) {
    //     this.pieces = data.board;
    //     this.currentPlayer = data.current_player;
    //     this.lastMove = data.move;
        
    //     if (data.captured_pieces) {
    //         this.capturedPieces = data.captured_pieces;
    //         this.updateCapturedPiecesDisplay();
    //     }
    //     const isWhite = this.currentPlayer === 'white';
    //     const opponentColor = isWhite ? 'black' : 'white';
    //     const isCheck = this.isKingInCheck(this.pieces, opponentColor);
    //     console.log('isKingInCheck:', this.isKingInCheck(board, color));
    //     console.log('Possible moves:', moves);
        
    //     if (data.status) {
    //         this.gameStatus = data.status;
    //         this.winner = data.winner;
    //         this.handleGameEnd();
    //     }
        
    //     if (data.move_count !== undefined) {
    //         this.moveCount = data.move_count;
    //     }
        
    //     if (data.last_capture_or_pawn_move !== undefined) {
    //         this.lastCaptureOrPawnMove = data.last_capture_or_pawn_move;
    //     }
        
    //     this.deselectPiece();
    //     this.updateGameStatus(
    //         this.isMyTurn() ? 'Ваш ход!' : 'Ожидаем хода соперника'
    //     );
    //     this.renderBoard();
    // }
//     handleGameUpdate(data) {
//     try {
//         // 1. Обновляем состояние доски и текущего игрока
//         this.pieces = data.board || this.pieces;
//         this.currentPlayer = data.current_player || this.currentPlayer;
//         this.lastMove = data.move || this.lastMove;

//         // 2. Обновляем список съеденных фигур
//         if (data.captured_pieces) {
//             this.capturedPieces = data.captured_pieces;
//             this.updateCapturedPiecesDisplay();
//         }

//         // 3. Обновляем счетчики ходов (для правила 50 ходов)
//         if (data.move_count !== undefined) {
//             this.moveCount = data.move_count;
//         }
//         if (data.last_capture_or_pawn_move !== undefined) {
//             this.lastCaptureOrPawnMove = data.last_capture_or_pawn_move;
//         }

//         // 4. Проверяем состояние игры
//         const currentColor = this.currentPlayer === 'white' ? 'white' : 'black';
//         const opponentColor = currentColor === 'white' ? 'black' : 'white';

//         // 4.1. Проверяем шах
//         const isCheck = this.isKingInCheck(this.pieces, opponentColor);
//         console.log('game-update')
//         // 4.2. Проверяем мат
//         if (isCheck) {
//             console.log('isCheck')
//             const isCheckmate = this.isCheckmate(this.pieces, opponentColor);
//             if (isCheckmate) {
//                 this.gameStatus = 'checkmate';
//                 this.winner = currentColor;
//                 this.handleGameEnd();
//             }
//         } 
//         // 4.3. Проверяем пат
//         else if (this.isStalemate(this.pieces, opponentColor)) {
//             this.gameStatus = 'draw';
//             this.winner = null;
//             this.handleGameEnd();
//         }
//         // 4.4. Проверяем ничью по правилу 50 ходов
//         else if (this.moveCount - this.lastCaptureOrPawnMove >= 50) {
//             this.gameStatus = 'draw';
//             this.winner = null;
//             this.handleGameEnd();
//         }

//         // 5. Обновляем отображение доски
//         this.deselectPiece();
//         this.updateGameStatus(
//             this.isMyTurn() ? 'Ваш ход!' : 'Ожидаем хода соперника',
//             isCheck ? 'check' : 'normal'
//         );
//         this.renderBoard();

//         // 6. Обновляем информацию о текущем игроке
//         this.updateCurrentPlayerDisplay();

//         // 7. Логирование для отладки
//         // console.log('Game updated:', {
//         //     currentPlayer: this.currentPlayer,
//         //     isCheck,
//         //     gameStatus: this.gameStatus,
//         //     winner: this.winner
//         // });

//     } catch (error) {
//         console.error('Error in handleGameUpdate:', error);
//         this.updateGameStatus('Ошибка обновления игры', 'error');
//     }
// }
handleGameUpdate(data) {
    try {
        console.log(data)
        // 1. Обновляем состояние доски и текущего игрока
        this.pieces = data.board || this.pieces;
        this.currentPlayer = data.current_player || this.currentPlayer;
        this.isWhite = data.currentPlayer === 'White' ? true : false;
        this.lastMove = data.move || this.lastMove;
        this.winner = data.winner
        this.winner_user = data.winner_user
        this.gameStatus = data.status
        // 2. Обновляем список съеденных фигур
        if (data.captured_pieces) {
            this.capturedPieces = data.captured_pieces;
            this.updateCapturedPiecesDisplay();
        }

        // 3. Обновляем счетчики ходов
        if (data.move_count !== undefined) {
            this.moveCount = data.move_count;
        }
        if (data.last_capture_or_pawn_move !== undefined) {
            this.lastCaptureOrPawnMove = data.last_capture_or_pawn_move;
        }

        // 4. Определяем, кто только что сделал ход (противник текущего игрока)
        const justMovedColor = this.currentPlayer === 'white' ? 'black' : 'white';
        
        // // 5. Проверяем шах для текущего игрока (чтобы увидеть, поставил ли противник шах)
        const isCheck = this.isKingInCheck(this.pieces, this.isWhite);
        // console.log('ischeck', isCheck)
        // 6. Проверяем конечные состояния игры для игрока, который только что сделал ход
        if (this.gameStatus == "checkmate") {
            this.handleGameEnd();

        } else if (this.gameStatus == "draw") {
            this.winner = null;
            this.handleGameEnd();
        } else if (this.moveCount - this.lastCaptureOrPawnMove >= 50) {
            this.winner = null;
            this.handleGameEnd();
        }

        this.deselectPiece();
        if (this.gameStatus == 'active'){
            this.updateGameStatus(
            this.isMyTurn() ? 'Ваш ход!' : 'Ожидаем хода соперника',
            isCheck ? 'check' : 'normal'
        );
        }

        this.renderBoard();
        this.updateCurrentPlayerDisplay();

    } catch (error) {
        console.error('Error in handleGameUpdate:', error);
        this.updateGameStatus('Ошибка обновления игры', 'error');
    }
}
updateCurrentPlayerDisplay() {
    const element = document.getElementById('current-player');
    if (element) {
        if (this.gameStatus !== 'active') {
            element.textContent = '';
            return;
        }
        element.textContent = `Сейчас ходят: ${this.currentPlayer === 'white' ? 'Белые' : 'Чёрные'}`;
        element.className = this.currentPlayer === 'white' ? 'player-white' : 'player-black';
    }
}
    // 
    handleGameEnd() {
    let statusMessage = '';
    let statusClass = '';

    switch (this.gameStatus) {
        case 'checkmate':
            statusMessage = this.playerColor === this.winner 
                ? 'Вы победили! Мат!' 
                : 'Вы проиграли. Мат!';
            statusClass = 'checkmate';
            
            // // Send game end message to server
            // if (this.socket.readyState === WebSocket.OPEN) {
            //     this.socket.send(JSON.stringify({
            //         type: "end_game",
            //         move_type: "end_game",
            //         is_checkmate: true,
            //         winner: this.winner
            //     }));
            // }
           break;
            
        case 'draw':
            statusMessage = 'Игра завершена вничью';
            statusClass = 'stalemate';
            
            // // Send game end message to server
            // if (this.socket.readyState === WebSocket.OPEN) {
            //     this.socket.send(JSON.stringify({
            //         type: "end_game",
            //         move_type: "end_game",
            //         is_draw: true
            //     }));
            // }
            break;
            
        default:
            statusMessage = 'Игра завершена';
            statusClass = 'normal';
    }

    this.updateGameStatus(statusMessage, statusClass);
    this.gameOver = true;

    // Block the board
    const chessBoard = document.getElementById('chess-board');
    if (chessBoard) {
        chessBoard.style.pointerEvents = 'none';
    }

    this.showGameOverUI();
}
showGameOverUI() {
    const gameControls = document.querySelector('.game-controls');
    if (gameControls) {
        const gameOverDiv = document.createElement('div');
        gameOverDiv.className = 'game-over-message';
        
        if (this.gameStatus === 'checkmate') {
            gameOverDiv.innerHTML = `
                <h2>${this.playerColor === this.winner ? 'Победа!' : 'Поражение!'}</h2>
                <p>${this.playerColor === this.winner ? 'Вы поставили мат!' : 'Вам поставили мат!'}</p>
            `;
        } else {
            gameOverDiv.innerHTML = `<h2>Ничья!</h2><p>${this.getDrawReason()}</p>`;
        }
        
        const newGameBtn = document.createElement('button');
        newGameBtn.textContent = 'Новая игра';
        newGameBtn.addEventListener('click', () => window.location.reload());
        
        gameOverDiv.appendChild(newGameBtn);
        gameControls.appendChild(gameOverDiv);
    }
}
getDrawReason() {
    if (this.moveCount - this.lastCaptureOrPawnMove >= 50) {
        return 'Правило 50 ходов';
    }
    if (this.isInsufficientMaterial()) {
        return 'Недостаток материала';
    }
    return 'Патовая ситуация';
}

isInsufficientMaterial() {
    let whitePieces = [];
    let blackPieces = [];
    
    // Собираем все фигуры
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = this.pieces[row][col];
            if (piece) {
                if (piece === piece.toUpperCase()) {
                    whitePieces.push(piece.toLowerCase());
                } else {
                    blackPieces.push(piece.toLowerCase());
                }
            }
        }
    }
    
    // Только короли
    if (whitePieces.length === 1 && blackPieces.length === 1) {
        return true;
    }
    
    // Король + слон/конь против короля
    if ((whitePieces.length === 1 && blackPieces.length === 2 && 
         ['b', 'n'].includes(blackPieces[1])) ||
        (blackPieces.length === 1 && whitePieces.length === 2 && 
         ['b', 'n'].includes(whitePieces[1]))) {
        return true;
    }
    
    // Оба имеют только короля + слона, причем слоны одного цвета
    if (whitePieces.length === 2 && whitePieces.includes('b') &&
        blackPieces.length === 2 && blackPieces.includes('b')) {
        const whiteBishopSquare = this.findPiece('B');
        const blackBishopSquare = this.findPiece('b');
        
        if ((whiteBishopSquare.row + whiteBishopSquare.col) % 2 === 
            (blackBishopSquare.row + blackBishopSquare.col) % 2) {
            return true;
        }
    }
    
    return false;
}

    isMyTurn() {
        return this.playerColor === this.currentPlayer;
    }

    initBoard() {
        const chessBoard = document.getElementById('chess-board');
        if (!chessBoard) {
            console.error('Chess board element not found');
            return;
        }
        
        chessBoard.innerHTML = '';
        
        for (let row = 0; row < 8; row++) {
            for (let col = 0; col < 8; col++) {
                const square = document.createElement('div');
                square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
                square.dataset.row = row;
                square.dataset.col = col;
                
                const pieceImg = document.createElement('img');
                pieceImg.className = 'piece';
                square.appendChild(pieceImg);
                
                chessBoard.appendChild(square);
            }
        }
    }

    renderBoard() {
    const squares = document.querySelectorAll('.chess-square');
    squares.forEach(square => {
        const row = parseInt(square.dataset.row);
        const col = parseInt(square.dataset.col);
        const displayedRow = this.getDisplayedRow(row);
        const piece = this.pieces[row][col];
        const pieceImg = square.querySelector('.piece');
        
        // Обновляем координаты для отображения
        square.style.gridRow = displayedRow + 1;
        square.style.gridColumn = col + 1;
        square.className = `chess-square ${(row + col) % 2 === 0 ? 'white' : 'black'}`;
        if (piece) {
            pieceImg.src = this.pieceImages[piece];
            pieceImg.style.display = 'block';
            pieceImg.alt = piece;
        } else {
            pieceImg.style.display = 'none';
        }
        
        if (this.selectedPiece && this.selectedPiece.row === row && this.selectedPiece.col === col) {
            square.classList.add('selected');
        }
        if (this.capturedPieces) {
            this.updateCapturedPiecesDisplay();
        }
        
        const move = this.possibleMoves.find(m => m.row === row && m.col === col);
        if (move) {
            square.classList.add('possible-move');
            if (this.pieces[row][col] && !this.isSameColor(this.selectedPiece.piece, this.pieces[row][col])) {
                square.classList.add('attackable-piece');
            }
        }
    });
    
    // Обновляем координаты вокруг доски
    this.updateBoardCoordinates();
}
    addEventListeners() {
        const chessBoard = document.getElementById('chess-board');
        if (!chessBoard || !this.isPlayer) return;

        chessBoard.addEventListener('click', (event) => {
            if (this.gameOver || !this.isMyTurn()) return;
            
            const square = event.target.closest('.chess-square');
            if (!square) return;
            
            const row = parseInt(square.dataset.row);
            const col = parseInt(square.dataset.col);
            const piece = this.pieces[row][col];
            
            this.handleSquareClick(row, col, piece);
        });
    }

    handleSquareClick(row, col, piece) {
        if (!this.isMyTurn() || !this.isPlayer) return;
        if (this.selectedPiece && this.possibleMoves.some(m => m.row === row && m.col === col)) {
            this.movePiece(row, col);
            return;
        }
        
        if (this.selectedPiece && this.selectedPiece.row === row && this.selectedPiece.col === col) {
            this.deselectPiece();
            return;
        }
        
        if (piece && this.isOwnPiece(piece)) {
            this.selectPiece(row, col, piece);
        } else {
            this.deselectPiece();
        }
    }

    isOwnPiece(piece) {
        if (!piece) return false;
        const isWhitePiece = piece === piece.toUpperCase();
        return (isWhitePiece && this.playerColor === 'white') || 
               (!isWhitePiece && this.playerColor === 'black');
    }

    isSameColor(piece1, piece2) {
        if (!piece1 || !piece2) return false;
        const isWhite1 = piece1 === piece1.toUpperCase();
        const isWhite2 = typeof piece2 === 'string' ? piece2 === piece2.toUpperCase() : piece2 === 'white';
        return isWhite1 === isWhite2;
    }

    selectPiece(row, col, piece) {
        this.selectedPiece = { row, col, piece };
        this.possibleMoves = this.getPossibleMoves(row, col, piece);
        this.renderBoard();
    }

    deselectPiece() {
        this.selectedPiece = null;
        this.possibleMoves = [];
        this.renderBoard();
    }

    movePiece(toRow, toCol) {
        if (!this.selectedPiece) return;
        
        const fromPos = this.toChessNotation(this.selectedPiece.row, this.selectedPiece.col);
        const toPos = this.toChessNotation(toRow, toCol);
        
        if (this.selectedPiece.piece.toLowerCase() === 'p' && (toRow === 0 || toRow === 7)) {
            this.showPromotionDialog(fromPos, toPos);
            return;
        }
        
        this.sendMove(fromPos, toPos);
        this.deselectPiece();
    }

    // sendMove(from, to, promotion = null) {
    //     // Проверяем условия окончания игры перед отправкой хода
    //     const isCheckmate = this.isCheckmate(this.pieces, this.currentPlayer);
    //     const isDraw = this.moveCount - this.lastCaptureOrPawnMove >= 100;
    //     console.log('sendMove')
    //     console.log(isCheckmate,isDraw)
    //     if (this.socket.readyState === WebSocket.OPEN) {
    //         this.socket.send(JSON.stringify({
    //             type: "make_move",
    //             from,
    //             to,
    //             promotion,
    //             is_checkmate: isCheckmate,
    //             is_draw: isDraw
    //         }));
    //     }
    // }

    toChessNotation(row, col) {
        const letter = String.fromCharCode(97 + col);
        const number = 8 - row;
        return `${letter}${number}`;
    }
//     sendMove(from, to, promotion = null) {
//     // Создаем временную копию доски для проверки
//     const tempBoard = this.copyBoard();
//     const fromPos = this.parseChessNotation(from);
//     const toPos = this.parseChessNotation(to);
    
//     // Применяем ход на временной доске
//     const movingPiece = tempBoard[fromPos.row][fromPos.col];
//     tempBoard[fromPos.row][fromPos.col] = '';
//     tempBoard[toPos.row][toPos.col] = movingPiece;
    
//     // Определяем цвет текущего игрока и противника
//     const currentColor = this.playerColor;
//     const opponentColor = currentColor === 'white' ? 'black' : 'white';
    
    
//     // Проверяем, находится ли король противника под шахом после этого хода
//     const isCheck = this.isKingInCheck(tempBoard, !this.isWhite);
    
//     // Если шах - проверяем мат
//     let isCheckmate = false;
//     if (isCheck) {
//         isCheckmate = this.isCheckmate(tempBoard, opponentColor);
//     }
    
//     // Проверка на ничью (правило 50 ходов)
//     const isDraw = this.moveCount - this.lastCaptureOrPawnMove >= 50;
//     console.log('Send move:',isCheck,isCheckmate)
//     if (this.socket.readyState === WebSocket.OPEN) {
//         this.socket.send(JSON.stringify({
//             type: "make_move",
//             from,
//             to,
//             promotion,
//             is_check: isCheck,       // Отправляем информацию о шахе
//             is_checkmate: isCheckmate, // Отправляем информацию о мате
//             is_draw: isDraw,         // Отправляем информацию о ничье
//             current_player: this.playerColor // Отправляем текущего игрока
//         }));
//     }
    
//     // Если мат - обрабатываем завершение игры
//     if (isCheckmate) {
//         this.gameStatus = 'checkmate';
//         this.winner = this.playerColor;
//         this.handleGameEnd();
//     } else if (isDraw) {
//         this.gameStatus = 'draw';
//         this.handleGameEnd();
//     }
// }
sendMove(from, to, promotion = null) {
    // console.group('sendMove');
    // console.log(`Move from ${from} to ${to}, promotion: ${promotion}`);
    
    const tempBoard = this.copyBoard();
    const fromPos = this.parseChessNotation(from);
    const toPos = this.parseChessNotation(to);
    
    // console.log('From position:', fromPos);
    // console.log('To position:', toPos);
    
    // Применяем ход
    const movingPiece = tempBoard[fromPos.row][fromPos.col];
    tempBoard[fromPos.row][fromPos.col] = '';
    tempBoard[toPos.row][toPos.col] = movingPiece;
    
    // console.log('Temp board after move:');
    // console.table(tempBoard);
    
    const isCurrentPlayerWhite = this.playerColor === 'white';
    const isOpponentWhite = !isCurrentPlayerWhite;
    
    // console.log('Current player is white?', isCurrentPlayerWhite);
    // console.log('Opponent is white?', isOpponentWhite);
    
    // Проверяем шах
    const isCheck = this.isKingInCheck(tempBoard, isOpponentWhite);
    // console.log('Is opponent in check?', isCheck);
    
    // Проверяем мат
    let isCheckmate = false;
    if (isCheck) {
        isCheckmate = this.isCheckmate(tempBoard, isOpponentWhite);
        // console.log('Is opponent in checkmate?', isCheckmate);
    }
    
    // Проверка на ничью
    const isDraw = this.moveCount - this.lastCaptureOrPawnMove >= 50;
    // console.log('Is draw by 50 moves rule?', isDraw);
    
    // Отправка на сервер
    if (this.socket.readyState === WebSocket.OPEN) {
        console.log('Sending move to server');
        this.socket.send(JSON.stringify({
            type: "make_move",
            from,
            to,
            promotion,
            is_check: isCheck,
            is_checkmate: isCheckmate,
            is_draw: isDraw,
            current_player: this.playerColor
        }));
    }
    
    // Обработка конечных состояний
    // if (isCheckmate) {
    //     // console.log('Checkmate detected!');
    //     this.gameStatus = 'checkmate';
    //     this.winner = this.playerColor;
    //     // this.handleGameEnd();
    // } else if (isDraw) {
    //     // console.log('Draw detected!');
    //     this.gameStatus = 'draw';
    //     // this.handleGameEnd();
    // }
    
    console.groupEnd();
}

// Вспомогательная функция для преобразования шахматной нотации
parseChessNotation(pos) {
    const col = pos.charCodeAt(0) - 'a'.charCodeAt(0);
    const row = 8 - parseInt(pos[1]);
    return { row, col };
}

    updateGameStatus(message, type = 'normal') {
        const statusElement = document.getElementById('game-status');
        if (statusElement) {
            statusElement.textContent = message;
            statusElement.className = `status-${type}`;
        }
    }

    getPossibleMoves(row, col, piece) {
    const moves = this.getRawMovesForPiece(row, col, piece, true); // ignoreCheck=true
    return this.filterLegalMoves(row, col, piece, moves);
}
    
    getMovesForPiece(row, col, piece) {
        let moves;
        switch (piece.toLowerCase()) {
            case 'p': moves = this.getPawnMoves(row, col, piece); break;
            case 'r': moves = this.getRookMoves(row, col, piece); break;
            case 'n': moves = this.getKnightMoves(row, col, piece); break;
            case 'b': moves = this.getBishopMoves(row, col, piece); break;
            case 'q': moves = this.getQueenMoves(row, col, piece); break;
            case 'k': moves = this.getKingMoves(row, col, piece); break;
            default: moves = [];
        }
        return moves;
    }

    // getPawnMoves(row, col, piece, ignoreCheck = false) {
    //     const moves = [];
    //     const direction = piece === 'P' ? -1 : 1;
    //     const startRow = piece === 'P' ? 6 : 1;

    //     if (this.pieces[row + direction]?.[col] === '') {
    //         moves.push({ row: row + direction, col });
    //         if (row === startRow && this.pieces[row + 2 * direction]?.[col] === '') {
    //             moves.push({ row: row + 2 * direction, col });
    //         }
    //     }

    //     for (let dx of [-1, 1]) {
    //         const targetCol = col + dx;
    //         const targetRow = row + direction;
    //         if (targetCol >= 0 && targetCol < 8 && targetRow >= 0 && targetRow < 8) {
    //             const targetPiece = this.pieces[targetRow][targetCol];
    //             if (targetPiece && !this.isSameColor(piece, targetPiece)) {
    //                 moves.push({ 
    //                     row: targetRow, 
    //                     col: targetCol,
    //                     isCapture: true
    //                 });
    //             }
    //             else if (this.lastMove?.piece?.toLowerCase() === 'p' && 
    //                     Math.abs(this.lastMove.from.row - this.lastMove.to.row) === 2 &&
    //                     this.lastMove.to.row === row &&
    //                     this.lastMove.to.col === targetCol) {
    //                 moves.push({ 
    //                     row: targetRow, 
    //                     col: targetCol,
    //                     isCapture: true,
    //                     isEnPassant: true
    //                 });
    //             }
    //         }
    //     }
    //     return ignoreCheck ? moves : this.filterLegalMoves(row, col, piece, moves);
    // }
    isEmpty(row, col) {
    return row >= 0 && row < 8 && col >= 0 && col < 8 && 
           this.pieces[row][col] === '';
}
hasOpponentPiece(row, col, isWhite) {
    return row >= 0 && row < 8 && col >= 0 && col < 8 && 
           this.pieces[row][col] !== '' && 
           (this.pieces[row][col] === this.pieces[row][col].toUpperCase()) !== isWhite;
}
canEnPassant(row, col, newRow, newCol, isWhite) {
    // Проверяем, есть ли информация о последнем ходе
    if (!this.lastMove || !this.lastMove.to || !this.lastMove.from) {
        return false;
    }
    
    // Проверяем, что на целевой клетке действительно пешка
    const lastPiece = this.pieces[this.lastMove.to.row]?.[this.lastMove.to.col];
    if (!lastPiece || lastPiece.toLowerCase() !== 'p') {
        return false;
    }
    
    // Проверяем условия для взятия на проходе
    return (
        this.isEmpty(newRow, newCol) &&
        Math.abs(this.lastMove.from.row - this.lastMove.to.row) === 2 &&
        this.lastMove.to.row === row &&
        this.lastMove.to.col === newCol
    );
}
getPawnMoves(row, col, piece, ignoreCheck = false) {
    const moves = [];
    const isWhite = piece === 'P';
    const direction = isWhite ? -1 : 1;
    const startRow = isWhite ? 6 : 1;

    // Обычный ход вперёд
    if (this.isEmpty(row + direction, col)) {
        moves.push({row: row + direction, col});
        
        // Двойной ход с начальной позиции
        if (row === startRow && this.isEmpty(row + 2 * direction, col)) {
            moves.push({row: row + 2 * direction, col});
        }
    }

    // Взятия
    for (const dx of [-1, 1]) {
        const newCol = col + dx;
        const newRow = row + direction;
        
        if (newCol >= 0 && newCol < 8) {
            // Обычное взятие
            if (this.hasOpponentPiece(newRow, newCol, isWhite)) {
                moves.push({
                    row: newRow,
                    col: newCol,
                    isCapture: true
                });
            }
            
            // Взятие на проходе
            if (this.lastMove && this.canEnPassant(row, col, newRow, newCol, isWhite)) {
                moves.push({
                    row: newRow,
                    col: newCol,
                    isCapture: true,
                    isEnPassant: true
                });
            }
        }
    }

    return ignoreCheck ? moves : this.filterLegalMoves(row, col, piece, moves);
}
    getRookMoves(row, col, piece, ignoreCheck = false) {
        const moves = [];
        const directions = [
            { r: 1, c: 0 }, { r: -1, c: 0 }, 
            { r: 0, c: 1 }, { r: 0, c: -1 }
        ];

        for (let dir of directions) {
            let r = row, c = col;
            while (true) {
                r += dir.r;
                c += dir.c;
                if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
                
                const targetPiece = this.pieces[r][c];
                if (!targetPiece) {
                    moves.push({ row: r, col: c });
                } else {
                    if (!this.isSameColor(piece, targetPiece)) {
                        moves.push({ 
                            row: r, 
                            col: c,
                            isCapture: true
                        });
                    }
                    break;
                }
            }
        }
        return ignoreCheck ? moves : this.filterLegalMoves(row, col, piece, moves);
    }

    getKnightMoves(row, col, piece, ignoreCheck = false) {
        const moves = [];
        const directions = [
            { r: 2, c: 1 }, { r: 2, c: -1 },
            { r: -2, c: 1 }, { r: -2, c: -1 },
            { r: 1, c: 2 }, { r: 1, c: -2 },
            { r: -1, c: 2 }, { r: -1, c: -2 },
        ];

        for (let dir of directions) {
            const newRow = row + dir.r;
            const newCol = col + dir.c;
            if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
                const targetPiece = this.pieces[newRow][newCol];
                if (!targetPiece) {
                    moves.push({ row: newRow, col: newCol });
                } else if (!this.isSameColor(piece, targetPiece)) {
                    moves.push({ 
                        row: newRow, 
                        col: newCol,
                        isCapture: true
                    });
                }
            }
        }
        return ignoreCheck ? moves : this.filterLegalMoves(row, col, piece, moves);
    }

    getBishopMoves(row, col, piece, ignoreCheck = false) {
        const moves = [];
        const directions = [
            { r: 1, c: 1 }, { r: 1, c: -1 }, 
            { r: -1, c: 1 }, { r: -1, c: -1 }
        ];

        for (let dir of directions) {
            let r = row, c = col;
            while (true) {
                r += dir.r;
                c += dir.c;
                if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
                
                const targetPiece = this.pieces[r][c];
                if (!targetPiece) {
                    moves.push({ row: r, col: c });
                } else {
                    if (!this.isSameColor(piece, targetPiece)) {
                        moves.push({ 
                            row: r, 
                            col: c,
                            isCapture: true
                        });
                    }
                    break;
                }
            }
        }
        return ignoreCheck ? moves : this.filterLegalMoves(row, col, piece, moves);
    }

    getQueenMoves(row, col, piece, ignoreCheck = false) {
        return [
            ...this.getRookMoves(row, col, piece, true),
            ...this.getBishopMoves(row, col, piece, true)
        ].filter(move => 
            ignoreCheck ? true : this.filterLegalMoves(row, col, piece, [move]).length > 0
        );
    }

    getKingMoves(row, col, piece, ignoreCheck = false) {
    // console.log(`Calculating king moves for ${piece} at [${row},${col}]`);
    const moves = [];
    const isWhite = piece === 'K';
    const directions = [
        { r: 1, c: 0 }, { r: -1, c: 0 },   // vertical
        { r: 0, c: 1 }, { r: 0, c: -1 },   // horizontal
        { r: 1, c: 1 }, { r: 1, c: -1 },   // diagonals
        { r: -1, c: 1 }, { r: -1, c: -1 }  // diagonals
    ];

    // 1. Check normal king moves
    for (const dir of directions) {
        const newRow = row + dir.r;
        const newCol = col + dir.c;

        // Check board boundaries
        if (newRow < 0 || newRow >= 8 || newCol < 0 || newCol >= 8) {
            // console.log(`[${newRow},${newCol}] - out of bounds`);
            continue;
        }

        const targetPiece = this.pieces[newRow][newCol];
        // console.log(`Checking [${newRow},${newCol}] with piece ${targetPiece}`);

        // Skip squares with own pieces
        if (targetPiece && this.isSameColor(piece, targetPiece)) {
            // console.log(`[${newRow},${newCol}] - own piece`);
            continue;
        }

        // Create temporary board to simulate move
        const tempBoard = this.copyBoard();
        tempBoard[newRow][newCol] = piece;
        tempBoard[row][col] = '';

        // For captures - check if the square is attacked by another piece
        if (targetPiece) {
            // console.log(`[${newRow},${newCol}] - capture move, checking for attackers`);
            let squareUnderAttack = false;
            
            // Check all enemy pieces that could attack this square
            for (let r = 0; r < 8 && !squareUnderAttack; r++) {
                for (let c = 0; c < 8 && !squareUnderAttack; c++) {
                    const enemyPiece = tempBoard[r][c];
                    if (enemyPiece && !this.isSameColor(piece, enemyPiece)) {
                        const enemyMoves = this.getRawMovesForPiece(r, c, enemyPiece, true);
                        // console.log(`Checking enemy ${enemyPiece} at [${r},${c}] - moves:`, enemyMoves);
                        
                        if (enemyMoves.some(m => m.row === newRow && m.col === newCol)) {
                            // console.log(`[${newRow},${newCol}] - under attack by ${enemyPiece} at [${r},${c}]`);
                            squareUnderAttack = true;
                        }
                    }
                }
            }

            if (squareUnderAttack) {
                // console.log(`[${newRow},${newCol}] - SKIPPING - square under attack after capture`);
                continue;
            }
        }

        // Check if new position is safe
        const isAttacked = this.isSquareAttacked(newRow, newCol, !isWhite, tempBoard);
        // console.log(`[${newRow},${newCol}] - isAttacked: ${isAttacked}`);
        
        if (!isAttacked) {
            moves.push({
                row: newRow,
                col: newCol,
                isCapture: !!targetPiece
            });
            // console.log(`[${newRow},${newCol}] - ADDED as valid move`);
        } else {
            // console.log(`[${newRow},${newCol}] - SKIPPING - square under attack`);
        }
    }

    // 2. Check castling (if king not in check and not ignoring checks)
    if (!ignoreCheck && !this.isKingInCheck(this.pieces, isWhite)) {
        // console.log('Checking castling possibilities');
        const color = isWhite ? 'white' : 'black';
        const backRank = isWhite ? 7 : 0;

        // Check if king is on starting position
        if (row === backRank && col === 4) {
            // Kingside castling
            if (this.castlingRights[color]?.kingside &&
                this.isEmpty(backRank, 5) &&
                this.isEmpty(backRank, 6) &&
                this.pieces[backRank][7]?.toLowerCase() === 'r') {

                // Check safety of intermediate squares
                const squaresSafe = [5, 6].every(c => 
                    !this.isSquareAttacked(backRank, c, !isWhite)
                );

                if (squaresSafe) {
                    moves.push({
                        row: backRank,
                        col: 6,
                        isCastling: true,
                        type: color.toUpperCase() + '_KINGSIDE'
                    });
                    // console.log('Added kingside castling');
                }
            }

            // Queenside castling
            if (this.castlingRights[color]?.queenside &&
                this.isEmpty(backRank, 3) &&
                this.isEmpty(backRank, 2) &&
                this.isEmpty(backRank, 1) &&
                this.pieces[backRank][0]?.toLowerCase() === 'r') {

                // Check safety of intermediate squares
                const squaresSafe = [2, 3].every(c => 
                    !this.isSquareAttacked(backRank, c, !isWhite)
                );

                if (squaresSafe) {
                    moves.push({
                        row: backRank,
                        col: 2,
                        isCastling: true,
                        type: color.toUpperCase() + '_QUEENSIDE'
                    });
                    // console.log('Added queenside castling');
                }
            }
        }
    }

    // console.log('Final king moves:', moves);
    return moves;
}


    // filterLegalMoves(row, col, piece, moves) {
    //     const isWhite = piece === piece.toUpperCase();
    //     const isInCheck = this.isKingInCheck(this.pieces, isWhite);
        
    //     if (!isInCheck) {
    //         return moves.filter(move => {
    //             const newPieces = this.copyBoard();
    //             newPieces[move.row][move.col] = piece;
    //             newPieces[row][col] = '';
    //             return !this.isKingInCheck(newPieces, isWhite);
    //         });
    //     }
        
    //     return moves.filter(move => {
    //         if (this.doesMoveBlockCheck(row, col, move, piece, isWhite)) {
    //             return true;
    //         }
            
    //         if (piece.toLowerCase() === 'k') {
    //             const newPieces = this.copyBoard();
    //             newPieces[move.row][move.col] = piece;
    //             newPieces[row][col] = '';
    //             return !this.isKingInCheck(newPieces, isWhite);
    //         }
            
    //         return false;
    //     });
    // }
//     checkAttackerBehind(row, col, direction, isWhite, board) {
//     // Определяем типы фигур, которые могут атаковать с этого направления
//     const attackerTypes = (direction.r === 0 || direction.c === 0) 
//         ? ['r', 'q']  // Вертикаль/горизонталь - ладья или ферзь
//         : ['b', 'q']; // Диагональ - слон или ферзь

//     // Идем в обратном направлении от короля
//     let r = row - direction.r;
//     let c = col - direction.c;

//     while (r >= 0 && r < 8 && c >= 0 && c < 8) {
//         const piece = board[r][c];
//         if (piece) {
//             // Если нашли фигуру противника нужного типа
//             return ((piece === piece.toUpperCase()) !== isWhite) && 
//                    attackerTypes.includes(piece.toLowerCase());
//         }
//         r -= direction.r;
//         c -= direction.c;
//     }

//     return false;
// }
    filterLegalMoves(row, col, piece, moves) {
    const isWhite = piece === piece.toUpperCase();
    const kingPos = this.findKing(isWhite);
    if (!kingPos) {
        return [];
    }

    // Создаем копию доски для проверки
    const tempBoard = this.copyBoard();
    const originalPiece = tempBoard[row][col];
    tempBoard[row][col] = ''; // Убираем фигуру с исходной позиции

    const validMoves = moves.filter(move => {
        // console.log(row,col)
        // console.log(move)
        const targetPiece = tempBoard[move.row][move.col];
        tempBoard[move.row][move.col] = originalPiece; // Ставим фигуру на новую позицию
        // console.log('tempboard')
        // console.table(tempBoard)
        // Для короля проверяем его новую позицию
        if (piece.toLowerCase() === 'k') {
            // console.log(filter)
            const kingStillInCheck = this.isSquareAttacked(move.row, move.col, !isWhite, tempBoard);
            tempBoard[move.row][move.col] = targetPiece; // Восстанавливаем доску
            return !kingStillInCheck;
        }
        
        // Для других фигур проверяем позицию короля
        const currentKingPos = piece.toLowerCase() === 'k' ? 
            { row: move.row, col: move.col } : 
            this.findKingInBoard(tempBoard, isWhite);
        
        const kingInCheck = this.isSquareAttacked(currentKingPos.row, currentKingPos.col, !isWhite, tempBoard);
        tempBoard[move.row][move.col] = targetPiece; // Восстанавливаем доску
        return !kingInCheck;
    });

    return validMoves;
}

// isKingInCheck(board, isWhite) {
//     const kingSymbol = isWhite ? 'K' : 'k';
//     const kingPos = this.findKingInBoard(board, isWhite);
//     // console.log(this.pieces)
//     if (!kingPos) return false;
//     let bolisSquareAttacked = this.isSquareAttacked(kingPos.row, kingPos.col, !isWhite, board);
//     // console.log(bolisSquareAttacked)
//     return bolisSquareAttacked;
// }
isKingInCheck(board, isWhite) {
    // console.group('isKingInCheck');
    // console.log('Checking for', isWhite ? 'white' : 'black', 'king');
    // console.table(board);
    
    const kingSymbol = isWhite ? 'K' : 'k';
    const kingPos = this.findKingInBoard(board, isWhite);
    // console.log('King position:', kingPos);
    
    if (!kingPos) {
        // console.log('King not found!');
        // console.groupEnd();
        return false;
    }
    
    const isAttacked = this.isSquareAttacked(kingPos.row, kingPos.col, !isWhite, board);
    // console.log('Is king attacked:', isAttacked);
    // console.groupEnd();
    return isAttacked;
}
findKingInBoard(board, isWhite) {
    const kingSymbol = isWhite ? 'K' : 'k';
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            if (board[r][c] === kingSymbol) {
                return { row: r, col: c };
            }
        }
    }
    return null;
}
// getAttackPath(kingPos, attacker) {
//     const path = [];
//     const dr = attacker.row - kingPos.row;
//     const dc = attacker.col - kingPos.col;
//     console.log('Calculating attack path from', attacker, 'to', kingPos, 'dR:', dr, 'dC:', dc);

//     // Для линейных атак
//     if (dr === 0 || dc === 0 || Math.abs(dr) === Math.abs(dc)) {
//         const stepR = dr === 0 ? 0 : dr > 0 ? 1 : -1;
//         const stepC = dc === 0 ? 0 : dc > 0 ? 1 : -1;
        
//         let r = kingPos.row + stepR;
//         let c = kingPos.col + stepC;
//         while (r !== attacker.row || c !== attacker.col) {
//             path.push({row: r, col: c});
//             console.log('Adding to path:', r, c);
//             r += stepR;
//             c += stepC;
//         }
//     }
    
//     console.log('Final attack path:', path);
//     return path;
// }
// Улучшенный метод проверки блокировки
isBetween(kingPos, attackerPos, row, col) {
    const dr = attackerPos.row - kingPos.row;
    const dc = attackerPos.col - kingPos.col;
    
    // Для вертикальной/горизонтальной атаки
    if (dr === 0 || dc === 0) {
        const stepR = dr === 0 ? 0 : dr > 0 ? 1 : -1;
        const stepC = dc === 0 ? 0 : dc > 0 ? 1 : -1;
        
        let r = kingPos.row + stepR;
        let c = kingPos.col + stepC;
        while (r !== attackerPos.row || c !== attackerPos.col) {
            if (r === row && c === col) return true;
            r += stepR;
            c += stepC;
        }
    }
    // Для диагональной атаки
    else if (Math.abs(dr) === Math.abs(dc)) {
        const stepR = dr > 0 ? 1 : -1;
        const stepC = dc > 0 ? 1 : -1;
        
        let r = kingPos.row + stepR;
        let c = kingPos.col + stepC;
        while (r !== attackerPos.row || c !== attackerPos.col) {
            if (r === row && c === col) return true;
            r += stepR;
            c += stepC;
        }
    }
    
    return false;
}
// canBlockCheck(kingPos, attackerPos, move, isWhite) {
//     const attackerPiece = this.pieces[attackerPos.row][attackerPos.col].toLowerCase();
    
//     // Конь атакует - нельзя блокировать, только взять
//     if (attackerPiece === 'n') return false;
    
//     // Определяем направление атаки
//     const dr = attackerPos.row - kingPos.row;
//     const dc = attackerPos.col - kingPos.col;
    
//     // Если атака по диагонали или прямой
//     if (Math.abs(dr) === Math.abs(dc) || dr === 0 || dc === 0) {
//         const stepR = dr === 0 ? 0 : dr > 0 ? 1 : -1;
//         const stepC = dc === 0 ? 0 : dc > 0 ? 1 : -1;
        
//         // Проверяем все клетки между королём и атакующей фигурой
//         let r = kingPos.row + stepR;
//         let c = kingPos.col + stepC;
//         while (r !== attackerPos.row || c !== attackerPos.col) {
//             if (move.row === r && move.col === c) {
//                 return true;
//             }
//             r += stepR;
//             c += stepC;
//         }
//     }
    
//     return false;
// }

    // doesMoveBlockCheck(fromRow, fromCol, move, piece, isWhite) {
    //     if (piece.toLowerCase() === 'k') return false;
        
    //     const kingPos = this.findKing(isWhite);
    //     if (!kingPos) return false;
        
    //     const newPieces = this.copyBoard();
    //     newPieces[move.row][move.col] = piece;
    //     newPieces[fromRow][fromCol] = '';
        
    //     return !this.isKingInCheck(newPieces, isWhite);
    // }

    findKing(isWhite) {
        const kingSymbol = isWhite ? 'K' : 'k';
        for (let r = 0; r < 8; r++) {
            for (let c = 0; c < 8; c++) {
                if (this.pieces[r][c] === kingSymbol) {
                    return {row: r, col: c};
                }
            }   
        }
        return null;
    }
//     findAttacker(kingPos, isWhite) {
//     for (let r = 0; r < 8; r++) {
//         for (let c = 0; c < 8; c++) {
//             const piece = this.pieces[r][c];
//             if (piece && (piece === piece.toUpperCase()) !== isWhite) {
//                 const moves = this.getRawMovesForPiece(r, c, piece);
//                 if (moves.some(m => m.row === kingPos.row && m.col === kingPos.col)) {
//                     return { row: r, col: c };
//                 }
//             }
//         }
//     }
//     return null;
// }
isSquareAttacked(row, col, byWhite, board = this.pieces) {
    // console.log(`Checking if square [${row},${col}] is attacked by ${byWhite ? 'white' : 'black'}`);
    // console.table(board);

    // 1. Проверка атак пешек (особый случай, т.к. пешки бьют по диагонали)
    const pawnDir = byWhite ? -1 : 1; // Направление движения пешек
    for (let dc of [-1, 1]) { // Пешки атакуют по двум диагоналям
        const r = row - pawnDir; // ИЗМЕНЕНО: проверяем в направлении ОТ пешки
        const c = col + dc;
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const piece = board[r][c];
            if (piece && piece.toLowerCase() === 'p' && 
                (piece === piece.toUpperCase()) === byWhite) {
                // console.log(`Pawn attack found at [${r},${c}]`);
                return true;
            }
        }
    }

    // 2. Проверка атак коней
    const knightMoves = [
        {r: 2, c: 1}, {r: 2, c: -1},
        {r: -2, c: 1}, {r: -2, c: -1},
        {r: 1, c: 2}, {r: 1, c: -2},
        {r: -1, c: 2}, {r: -1, c: -2}
    ];
    for (let move of knightMoves) {
        const r = row + move.r;
        const c = col + move.c;
        if (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const piece = board[r][c];
            if (piece && piece.toLowerCase() === 'n' && 
                (piece === piece.toUpperCase()) === byWhite) {
                console.log(`Knight attack found at [${r},${c}]`);
                return true;
            }
        }
    }

    // 3. Проверка атак по прямым и диагоналям (ладьи, слоны, ферзи)
    const directions = [
        {r: 1, c: 0}, {r: -1, c: 0}, {r: 0, c: 1}, {r: 0, c: -1},  // Вертикаль/горизонталь
        {r: 1, c: 1}, {r: 1, c: -1}, {r: -1, c: 1}, {r: -1, c: -1}   // Диагонали
    ];

    for (let dir of directions) {
        let r = row + dir.r;
        let c = col + dir.c;
        const isStraight = (dir.c === 0 || dir.r === 0); // Определяем тип линии
        const validPieces = isStraight ? ['r', 'q'] : ['b', 'q']; // Какие фигуры могут атаковать
        
        while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            const piece = board[r][c];
            if (piece) {
                if (validPieces.includes(piece.toLowerCase()) && 
                    (piece === piece.toUpperCase()) === byWhite) {
                    // console.log(`${isStraight ? 'Rook/Queen' : 'Bishop/Queen'} attack found at [${r},${c}]`);
                    return true;
                }
                break; // Любая фигура прерывает линию
            }
            r += dir.r;
            c += dir.c;
        }
    }

    // 4. Проверка атак королем (соседние клетки)
    for (let dr = -1; dr <= 1; dr++) {
        for (let dc = -1; dc <= 1; dc++) {
            if (dr === 0 && dc === 0) continue; // Пропускаем текущую клетку
            const r = row + dr;
            const c = col + dc;
            if (r >= 0 && r < 8 && c >= 0 && c < 8) {
                const piece = board[r][c];
                if (piece && piece.toLowerCase() === 'k' && 
                    (piece === piece.toUpperCase()) === byWhite) {
                    // console.log(`King attack found at [${r},${c}]`);
                    return true;
                }
            }
        }
    }

    // console.log(`No attacks found on [${row},${col}]`);
    return false;
}
// isSquareAttacked(row, col, byWhite, board = this.pieces) {
//     // Проверка атак пешек
//     console.log('isAtack')
//     console.table(board)
//     const pawnDir = byWhite ? -1 : 1;
//     for (let dc of [-1, 1]) {
//         const r = row + pawnDir;
//         const c = col + dc;
//         if (r >= 0 && r < 8 && c >= 0 && c < 8) {
//             const piece = board[r][c];
//             if (piece && piece.toLowerCase() === 'p' && 
//                 (piece === piece.toUpperCase()) === byWhite) {
//                 return true;
//             }
//         }
//     }

//     // Проверка атак коней
//     const knightMoves = [
//         {r: 2, c: 1}, {r: 2, c: -1},
//         {r: -2, c: 1}, {r: -2, c: -1},
//         {r: 1, c: 2}, {r: 1, c: -2},
//         {r: -1, c: 2}, {r: -1, c: -2}
//     ];
//     for (let move of knightMoves) {
//         const r = row + move.r;
//         const c = col + move.c;
//         if (r >= 0 && r < 8 && c >= 0 && c < 8) {
//             const piece = board[r][c];
//             if (piece && piece.toLowerCase() === 'n' && 
//                 (piece === piece.toUpperCase()) === byWhite) {
//                 return true;
//             }
//         }
//     }

//     // Проверка атак по прямым и диагоналям (ладьи, слоны, ферзи)
//     const directions = [
//         {r: 1, c: 0}, {r: -1, c: 0}, {r: 0, c: 1}, {r: 0, c: -1},  // Ладьи/ферзи
//         {r: 1, c: 1}, {r: 1, c: -1}, {r: -1, c: 1}, {r: -1, c: -1}  // Слоны/ферзи
//     ];

//     for (let dir of directions) {
//         let r = row + dir.r;
//         let c = col + dir.c;
//         while (r >= 0 && r < 8 && c >= 0 && c < 8) {
//             const piece = board[r][c];
//             if (piece) {
//                 // Для ладей/слонов проверяем тип фигуры в зависимости от направления
//                 const isStraight = (dir.c === 0 || dir.r === 0);
//                 const validPieces = isStraight ? ['r', 'q'] : ['b', 'q'];
                
//                 if (validPieces.includes(piece.toLowerCase()) && 
//                     (piece === piece.toUpperCase()) === byWhite) {
//                     return true;
//                 }
//                 break; // Прерываем цикл, если нашли любую фигуру
//             }
//             r += dir.r;
//             c += dir.c;
//         }
//     }

//     // Проверка атак королем (на расстояние 1 клетки)
//     for (let dr = -1; dr <= 1; dr++) {
//         for (let dc = -1; dc <= 1; dc++) {
//             if (dr === 0 && dc === 0) continue;
//             const r = row + dr;
//             const c = col + dc;
//             if (r >= 0 && r < 8 && c >= 0 && c < 8) {
//                 const piece = board[r][c];
//                 if (piece && piece.toLowerCase() === 'k' && 
//                     (piece === piece.toUpperCase()) === byWhite) {
//                     return true;
//                 }
//             }
//         }
//     }

//     return false;
// }

  
blocksAllAttacks(tempBoard, kingPos, isWhite, attackers) {
    // Проверяем, остались ли атакующие после этого хода
    for (const attacker of attackers) {
        const attackerPiece = tempBoard[attacker.row][attacker.col];
        if (attackerPiece && (attackerPiece === attackerPiece.toUpperCase()) !== isWhite) {
            const moves = this.getRawMovesForPiece(attacker.row, attacker.col, attackerPiece);
            if (moves.some(m => m.row === kingPos.row && m.col === kingPos.col)) {
                return false;
            }
        }
    }
    return true;
}
findAllAttackers(kingPos, isWhite) {
    const attackers = [];
    for (let r = 0; r < 8; r++) {
        for (let c = 0; c < 8; c++) {
            const piece = this.pieces[r][c];
            if (piece && (piece === piece.toUpperCase()) !== isWhite) {
                const moves = this.getRawMovesForPiece(r, c, piece);
                if (moves.some(m => m.row === kingPos.row && m.col === kingPos.col)) {
                    attackers.push({row: r, col: c, piece});
                }
            }
        }
    }
    return attackers;
}
// canBlockCheck(kingPos, attackerPos, move, isWhite) {
//     const attackerPiece = this.pieces[attackerPos.row][attackerPos.col].toLowerCase();
    
//     // Конь атакует - нельзя блокировать, только взять
//     if (attackerPiece === 'n') {
//         return false;
//     }
    
//     // Для пешки - особый случай
//     if (attackerPiece === 'p') {
//         // Пешка может блокировать только если она бьёт атакующую фигуру
//         return move.row === attackerPos.row && move.col === attackerPos.col;
//     }
    
//     // Определяем направление атаки
//     const dr = attackerPos.row - kingPos.row;
//     const dc = attackerPos.col - kingPos.col;
    
//     // Если атака по диагонали или прямой
//     if (Math.abs(dr) === Math.abs(dc) || dr === 0 || dc === 0) {
//         const stepR = dr === 0 ? 0 : dr > 0 ? 1 : -1;
//         const stepC = dc === 0 ? 0 : dc > 0 ? 1 : -1;
        
//         // Проверяем все клетки между королём и атакующей фигурой
//         let r = kingPos.row + stepR;
//         let c = kingPos.col + stepC;
//         while (r !== attackerPos.row || c !== attackerPos.col) {
//             if (move.row === r && move.col === c) {
//                 return true;
//             }
//             r += stepR;
//             c += stepC;
//         }
//     }
    
//     return false;
// }

// getRawMovesForPiece(row, col, piece, ignoreCheck = false) {
//     switch (piece.toLowerCase()) {
//         case 'p': return this.getPawnMovesRaw(row, col, piece);
//         case 'r': return this.getRookMovesRaw(row, col, piece);
//         case 'n': return this.getKnightMovesRaw(row, col, piece);
//         case 'b': return this.getBishopMovesRaw(row, col, piece);
//         case 'q': return this.getQueenMovesRaw(row, col, piece);
//         case 'k': return this.getKingMovesRaw(row, col, piece);
//         default: return [];
//     }
// }
getRawMovesForPiece(row, col, piece, ignoreCheck = false) {
    // console.log(`Получаем ходы для ${piece} на [${row},${col}], ignoreCheck=${ignoreCheck}`);
    
    switch (piece.toLowerCase()) {
        case 'p': 
            const pawnMoves = this.getPawnMovesRaw(row, col, piece);
            // console.log('Ходы пешки:', pawnMoves);
            return pawnMoves;
        case 'r': 
            return this.getRookMovesRaw(row, col, piece);
        case 'n': 
            return this.getKnightMovesRaw(row, col, piece);
        case 'b': 
            return this.getBishopMovesRaw(row, col, piece);
        case 'q': 
            return this.getQueenMovesRaw(row, col, piece);
        case 'k': 
            return this.getKingMovesRaw(row, col, piece);
        default: 
            return [];
    }
}
getPawnMovesRaw(row, col, piece) {
// console.log(piece)
    const moves = [];
    const isWhite = piece === 'P';
    const direction = isWhite ? -1 : 1;
    const startRow = isWhite ? 6 : 1;

    // Обычный ход вперед
    if (this.isEmpty(row + direction, col)) {
        moves.push({row: row + direction, col});
        
        // Двойной ход с начальной позиции
        if (row === startRow && this.isEmpty(row + 2 * direction, col)) {
            moves.push({row: row + 2 * direction, col});
        }
    }

    // Взятия
    for (const dx of [-1, 1]) {
        const newCol = col + dx;
        const newRow = row + direction;
        
        if (newCol >= 0 && newCol < 8) {
            // Обычное взятие
            if (this.hasOpponentPiece(newRow, newCol, isWhite)) {
                moves.push({
                    row: newRow,
                    col: newCol,
                    isCapture: true
                });
            }
            
            // Взятие на проходе
            if (this.lastMove && this.canEnPassant(row, col, newRow, newCol, isWhite)) {
                moves.push({
                    row: newRow,
                    col: newCol,
                    isCapture: true,
                    isEnPassant: true
                });
            }
        }
    }

    return moves;
}
getRookMovesRaw(row, col, piece) {
    const moves = [];
    const directions = [
        { r: 1, c: 0 }, { r: -1, c: 0 }, 
        { r: 0, c: 1 }, { r: 0, c: -1 }
    ];

    for (let dir of directions) {
        let r = row, c = col;
        while (true) {
            r += dir.r;
            c += dir.c;
            if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
            
            const targetPiece = this.pieces[r][c];
            if (!targetPiece) {
                moves.push({ row: r, col: c });
            } else {
                if (!this.isSameColor(piece, targetPiece)) {
                    moves.push({ 
                        row: r, 
                        col: c,
                        isCapture: true
                    });
                }
                break;
            }
        }
    }
    return moves;
}
getKnightMovesRaw(row, col, piece) {
    const moves = [];
    const directions = [
        { r: 2, c: 1 }, { r: 2, c: -1 },
        { r: -2, c: 1 }, { r: -2, c: -1 },
        { r: 1, c: 2 }, { r: 1, c: -2 },
        { r: -1, c: 2 }, { r: -1, c: -2 }
    ];

    for (let dir of directions) {
        const newRow = row + dir.r;
        const newCol = col + dir.c;
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const targetPiece = this.pieces[newRow][newCol];
            if (!targetPiece || !this.isSameColor(piece, targetPiece)) {
                moves.push({ 
                    row: newRow, 
                    col: newCol,
                    isCapture: !!targetPiece
                });
            }
        }
    }
    return moves;
}

// Слон
getBishopMovesRaw(row, col, piece) {
    const moves = [];
    const directions = [
        { r: 1, c: 1 }, { r: 1, c: -1 }, 
        { r: -1, c: 1 }, { r: -1, c: -1 }
    ];

    for (let dir of directions) {
        let r = row, c = col;
        while (true) {
            r += dir.r;
            c += dir.c;
            if (r < 0 || r >= 8 || c < 0 || c >= 8) break;
            
            const targetPiece = this.pieces[r][c];
            if (!targetPiece) {
                moves.push({ row: r, col: c });
            } else {
                if (!this.isSameColor(piece, targetPiece)) {
                    moves.push({ 
                        row: r, 
                        col: c,
                        isCapture: true
                    });
                }
                break;
            }
        }
    }
    return moves;
}

// Ферзь (комбинация ладьи и слона)
getQueenMovesRaw(row, col, piece) {
    return [
        ...this.getRookMovesRaw(row, col, piece),
        ...this.getBishopMovesRaw(row, col, piece)
    ];
}

// Король
getKingMovesRaw(row, col, piece) {
    const moves = [];
    const directions = [
        { r: 1, c: 0 }, { r: -1, c: 0 },
        { r: 0, c: 1 }, { r: 0, c: -1 },
        { r: 1, c: 1 }, { r: 1, c: -1 },
        { r: -1, c: 1 }, { r: -1, c: -1 }
    ];

    const isWhite = piece === 'K';
    
    for (let dir of directions) {
        const newRow = row + dir.r;
        const newCol = col + dir.c;
        
        if (newRow >= 0 && newRow < 8 && newCol >= 0 && newCol < 8) {
            const targetPiece = this.pieces[newRow][newCol];
            if (!targetPiece || !this.isSameColor(piece, targetPiece)) {
                moves.push({ 
                    row: newRow, 
                    col: newCol,
                    isCapture: !!targetPiece
                });
            }
        }
    }

    // Рокировка (проверяем без учета шаха)
    if (!this.isKingInCheck(this.pieces, isWhite)) {
        const color = isWhite ? 'white' : 'black';
        const backRank = isWhite ? 7 : 0;
        
        if (row === backRank && col === 4) {
            // Короткая рокировка
            if (this.castlingRights[color]?.kingside && 
                this.pieces[backRank][5] === '' && 
                this.pieces[backRank][6] === '' && 
                this.pieces[backRank][7]?.toLowerCase() === 'r') {
                
                moves.push({ 
                    row: backRank, 
                    col: 6, 
                    isCastling: true,
                    type: isWhite ? 'WHITE_KINGSIDE' : 'BLACK_KINGSIDE'
                });
            }
            
            // Длинная рокировка
            if (this.castlingRights[color]?.queenside && 
                this.pieces[backRank][3] === '' && 
                this.pieces[backRank][2] === '' && 
                this.pieces[backRank][1] === '' && 
                this.pieces[backRank][0]?.toLowerCase() === 'r') {
                
                moves.push({ 
                    row: backRank, 
                    col: 2, 
                    isCastling: true,
                    type: isWhite ? 'WHITE_QUEENSIDE' : 'BLACK_QUEENSIDE'
                });
            }
        }
    }
    return moves;
}

    executeMove(from, to, promotionChoice = null) {
        const isWhite = this.currentPlayer === 'white';
        const newPieces = this.copyBoard();
        let piece = newPieces[from.row][from.col];
        let capturedPiece = newPieces[to.row][to.col];
        let newCastlingRights = this.updateCastlingRights(piece, from);
        let isPromotion = false;

        const result = {
            newPieces,
            newCastlingRights,
            capturedPiece,
            isCheck: false,
            isCheckmate: false,
            isStalemate: false,
            isPromotion: false,
            promotionPosition: null
        };

        if (piece.toLowerCase() === 'k' && Math.abs(from.col - to.col) === 2) {
            const castlingType = isWhite 
                ? (to.col === 6 ? 'WHITE_KINGSIDE' : 'WHITE_QUEENSIDE')
                : (to.col === 6 ? 'BLACK_KINGSIDE' : 'BLACK_QUEENSIDE');
            
            result.newPieces = this.performCastling(newPieces, castlingType);
            result.capturedPiece = null;
        } 
        else {
            result.newPieces[to.row][to.col] = piece;
            result.newPieces[from.row][from.col] = '';

            if (piece.toLowerCase() === 'p' && Math.abs(from.col - to.col) === 1 && !capturedPiece) {
                const direction = piece === 'P' ? -1 : 1;
                result.capturedPiece = result.newPieces[to.row - direction][to.col];
                result.newPieces[to.row - direction][to.col] = '';
            }

            if (piece.toLowerCase() === 'p' && (to.row === 0 || to.row === 7)) {
                result.isPromotion = true;
                result.promotionPosition = to;
                
                if (promotionChoice) {
                    result.newPieces[to.row][to.col] = promotionChoice;
                    result.isPromotion = false;
                } else {
                    result.newPieces[to.row][to.col] = piece;
                    result.newPieces[from.row][from.col] = '';
                    return result;
                }
            }
        }

        const opponentColor = isWhite ? 'black' : 'white';
        result.isCheck = this.isKingInCheck(result.newPieces, !isWhite);

        if (!result.isPromotion) {
            if (result.isCheck) {
                result.isCheckmate = this.isCheckmate(result.newPieces, !isWhite);
            } else {
                result.isStalemate = this.isStalemate(result.newPieces, !isWhite);
            }
        }

        return result;
    }
    
    performCastling(pieces, castlingType) {
        const newPieces = this.copyBoard(pieces);
        const { kingTo, rookFrom, rookTo } = this.getCastlingInfo(castlingType);
        
        newPieces[kingTo[0]][kingTo[1]] = newPieces[kingTo[0]][4];
        newPieces[kingTo[0]][4] = '';
        
        newPieces[rookTo[0]][rookTo[1]] = newPieces[rookFrom[0]][rookFrom[1]];
        newPieces[rookFrom[0]][rookFrom[1]] = '';
        
        return newPieces;
    }
    
    getCastlingInfo(type) {
        const CASTLING = {
            WHITE_KINGSIDE: { kingTo: [7, 6], rookFrom: [7, 7], rookTo: [7, 5] },
            WHITE_QUEENSIDE: { kingTo: [7, 2], rookFrom: [7, 0], rookTo: [7, 3] },
            BLACK_KINGSIDE: { kingTo: [0, 6], rookFrom: [0, 7], rookTo: [0, 5] },
            BLACK_QUEENSIDE: { kingTo: [0, 2], rookFrom: [0, 0], rookTo: [0, 3] }
        };
        return CASTLING[type];
    }
    
    updateCastlingRights(piece, from) {
        const newRights = {...this.castlingRights};
        const currentPlayer = this.currentPlayer;
        
        if (piece.toLowerCase() === 'k') {
            newRights[currentPlayer] = { kingside: false, queenside: false };
        } 
        else if (piece.toLowerCase() === 'r') {
            if (currentPlayer === 'white') {
                if (from.col === 0) newRights.white.queenside = false;
                if (from.col === 7) newRights.white.kingside = false;
            } else {
                if (from.col === 0) newRights.black.queenside = false;
                if (from.col === 7) newRights.black.kingside = false;
            }
        }
        
        return newRights;
    }
    
    // isCheckmate(board, color) {
    //     let isWhite = color === 'white' ? true : false

    //     if (!this.isKingInCheck(board, isWhite)) {
    //         return false;
    //     }
    //     console.log('isCheckmate',isWhite)
    //     console.table(board)
        

    //     // Проверяем, есть ли хотя бы один допустимый ход
    //     const kingSymbol = color === 'white' ? 'K' : 'k';
    //     for (let row = 0; row < 8; row++) {
    //         for (let col = 0; col < 8; col++) {
    //             const piece = board[row][col];
    //             if (piece && ((piece === piece.toUpperCase() && color === 'white') || 
    //                          (piece === piece.toLowerCase() && color === 'black'))) {
    //                 const moves = this.getRawMovesForPiece(row, col, piece);
    //                 for (const move of moves) {
    //                     const tempBoard = this.copyBoard();
    //                     tempBoard[move.row][move.col] = piece;
    //                     tempBoard[row][col] = '';
                        
    //                     if (!this.isKingInCheck(tempBoard, isWhite)) {
    //                         return false;
    //                     }
    //                 }
    //             }
    //         }
    //     }
    //     return true;
    // }
//     isCheckmate(board, isWhite) {
//     // Проверяем, находится ли король под шахом
//     if (!this.isKingInCheck(board, isWhite)) {
//         return false;
//     }

//     // Проверяем, есть ли хотя бы один допустимый ход
//     const kingSymbol = isWhite ? 'K' : 'k';
//     console.log('checkmate')
//     console.table(board)
//     for (let row = 0; row < 8; row++) {
//         for (let col = 0; col < 8; col++) {
//             const piece = board[row][col];
//             // Проверяем только фигуры нужного цвета
//             if (piece && (piece === piece.toUpperCase()) === isWhite) {
//                 const moves = this.getPossibleMoves(row, col, piece);
//                 if (moves.length > 0) {
//                     console.log(moves)
//                     return false; // Нашли допустимый ход - не мат
//                 }
//             }
//         }
//     }
    
//     return true; // Ни одного допустимого хода - мат
// }
isCheckmate(board, isWhite) {
    // console.group('Detailed Checkmate Check');
    // console.log(`Checking mate for ${isWhite ? 'white' : 'black'} pieces`);
    // console.log('Current board state:');
    // console.table(board);

    // 1. Find the king
    const kingSymbol = isWhite ? 'K' : 'k';
    const kingPos = this.findKingInBoard(board, isWhite);
    // console.log(`King (${kingSymbol}) position:`, kingPos);

    if (!kingPos) {
        // console.error('King not found!');
        // console.groupEnd();
        return false;
    }

    // 2. Check if king is in check
    const inCheck = this.isKingInCheck(board, isWhite);
    // console.log(`Is king in check: ${inCheck}`);
    
    if (!inCheck) {
        // console.log('King is not in check - not checkmate');
        // console.groupEnd();
        return false;
    }

    // console.log('King is in check, checking for legal moves...');

    // 3. Check all pieces for legal moves
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = board[row][col];
            if (!piece) continue;

            const isPieceWhite = piece === piece.toUpperCase();
            if (isPieceWhite === isWhite) {
                // console.log(`\nChecking ${isWhite ? 'white' : 'black'} piece ${piece} at [${row},${col}]`);
                
                const moves = this.getPossibleMoves(row, col, piece);
                // console.log('Possible moves:', moves);

                // Simulate each move to see if it removes check
                for (const move of moves) {
                    const tempBoard = this.copyBoard(board);
                    tempBoard[move.row][move.col] = piece;
                    tempBoard[row][col] = '';

                    const stillInCheck = this.isKingInCheck(tempBoard, isWhite);
                    // console.log(`Move to [${move.row},${move.col}], still in check: ${stillInCheck}`);

                    if (!stillInCheck) {
                        // console.log(`Found legal move that removes check - not checkmate`);
                        // console.groupEnd();
                        return false;
                    }
                }
            }
        }
    }

    // console.log('No legal moves found - checkmate!');
    // console.groupEnd();
    return true;
}
    isStalemate(pieces, color) {
    // 1. Король не должен быть под шахом
    if (this.isKingInCheck(pieces, this.isWhite)) {
        return false;
    }

    // 2. Проверяем, есть ли допустимые ходы у игрока color
    for (let row = 0; row < 8; row++) {
        for (let col = 0; col < 8; col++) {
            const piece = pieces[row][col];
            // Проверяем только фигуры нужного цвета
            if (piece && this.isSameColor(piece, color === 'white' ? 'K' : 'k')) {
                const moves = this.getPossibleMoves(row, col, piece);
                if (moves.length > 0) {
                    return false; // Нашли хотя бы один допустимый ход - не пат
                }
            }
        }
    }
    
    return true; // Ни одного допустимого хода - пат
}
    
    copyBoard(board = this.pieces) {
        return board.map(row => [...row]);
    }

}

document.addEventListener('DOMContentLoaded', () => {
    const chessContainer = document.getElementById('chess-game');
    if (!chessContainer) return;

    const gameId = chessContainer.dataset.game_id;
    if (!gameId) return;

    try {
        window.chessGame = new ChessGame(gameId);
    } catch (error) {
        console.error('Failed to initialize chess game:', error);
    }
});
</script>
{% endblock %}